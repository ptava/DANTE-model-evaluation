/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2412                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/

//--- Grid-related parameters ---//
grid
{
    building
    {
        ratio            2;     // Experimental campaign: 2 x 1 x 1 building ratio
        ref_size         0.08;  // Reference size [m] = building side length
    }

    surrounding
    {
        // Multipliers to define the domain size based on building height (to
        // match other grid that reflect experimental campaign)
        multiplier_z     5.625;
        multiplier_y     6.875;
        multiplier_x_in  2.85;
        multiplier_x_out 9.0;
    }

    control
    {
        // Overall cells count based on cells size in specific regions and
        // scaling factor named 'cells_scaling'.
        // - cells_scaling:
        //      ⇲ 1.0  -> nCells ~= 110M
        //      ⇲ 1.1  -> nCells ~= 84M
        //      ⇲ 1.25 -> nCells ~= 57M
        //      ⇲ 1.5  -> nCells ~= 33M
        //      ⇲ 2.0  -> nCells ~= 14M
        //      ⇲ 2.5  -> nCells ~= 8M
        //      ⇲ 3.0  -> nCells ~= 4M
        //      ⇲ 5.0  -> nCells ~= 1M
        //      ⇲ 7.0  -> nCells ~= 384K
        //      ⇲ 8.0  -> nCells ~= 272K
        // - cells_size_0: 
        //      ⇲ boundary layer first cell height
        //      ⇲ isotropic cell size near building corners
        // - cells_size_1:
        //      ⇲ height of cell at the top of the boundary layer
        // - cells_size_2:
        //      ⇲ control size in the centers of building faces
        // - cells_size_3:
        //      ⇲ isotropic cell size in the vicinity of the building
        // - cells_size_4:
        //      ⇲ cell size in the far field (inlet/sides)
        // - cells_size_5:
        //      ⇲ cell size in the far field (top/outlet)

        cells_scaling    2.0;
        cell_size_0      #calc " ${cells_scaling} * 0.0001 ";
        cell_size_1      #calc " ${cells_scaling} * 0.0010 ";
        cell_size_2      #calc " ${cells_scaling} * 0.0015 ";
        cell_size_3      #calc " ${cells_scaling} * 0.0025 ";
        cell_size_4      #calc " ${cells_scaling} * 0.0060 ";
        cell_size_5      #calc " ${cells_scaling} * 0.0090 ";

        // O-grid extent
        xyz_distance     $..building.ref_size;
    }

    coordinates
    {
        // Building
        building_ratio   $..building.ratio;
        building_side    $..building.ref_size;
        building_height  #calc " ${building_ratio} * ${building_side} ";
        building_xy      #calc " ${building_side}/2 ";

        // O-grid
        xyz_distance     $..control.xyz_distance;
        ogrid_z          #calc " ${building_height} + ${xyz_distance} ";
        ogrid_xy         #calc " ${building_xy} + ${xyz_distance} ";
    
        // Domain limits
        multiplier_z     $..surrounding.multiplier_z;
        multiplier_y     $..surrounding.multiplier_y;
        multiplier_x_in  $..surrounding.multiplier_x_in;
        multiplier_x_out $..surrounding.multiplier_x_out;
        z_min            0;
        z_max            #calc " ${building_height} * ${multiplier_z} ";
        x_min            #calc " -${building_height} * ${multiplier_x_in} ";
        x_max            #calc " ${building_height} * ${multiplier_x_out} ";
        y_min            #calc " -${building_height} * ${multiplier_y}/2 ";
        y_max            #calc " ${building_height} * ${multiplier_y}/2 ";

        // Other
        xy_distance_mid  #calc " ( ${ogrid_xy} + 0.02 ) ";
        xy_distance_top  #calc " ( ${xy_distance_mid} + 0.02 ) ";
        xy_distance_red  #calc " ( ${ogrid_xy} - 0.015 ) ";
        ogrid_radius     #calc " sqrt(2*pow($xy_distance_red,2)) ";
    }

    discretization
    {
        // To compute MASTER blocks cells number and grading
        // 'Z0': grading on vertical edges of the baseblock
        // 'Z1': grading on vertical edges of the topblock
        // 'B1': grading o-grid towards the building
        // 'B0': grading on xy building edges
        // 'X0': grading on x inlet
        // 'X1': grading on x outlet
        // 'Y0': grading on y left inlet
        // 'Y1': grading on y right inlet
        master
        {
            tags
            (
                Z0
                Z1
                B1
                B0
                X0
                X1
                Y0
                Y1
            );
            start_sizes
            (
                $...control.cell_size_0
                $...control.cell_size_3
                $...control.cell_size_3
                $...control.cell_size_0
                $...control.cell_size_4
                $...control.cell_size_3
                $...control.cell_size_4
                $...control.cell_size_3
            );
            mid_sizes
            (
                $...control.cell_size_1
                $...control.cell_size_4
                $...control.cell_size_1
                $...control.cell_size_1
                0
                $...control.cell_size_4
                0
                0
            );
            mid_points
            (
                0.20
                0.55
                0.85
                0.50
                0.0
                0.70
                0.0
                0.0
            );
            end_sizes
            (
                $...control.cell_size_3
                $...control.cell_size_5
                $...control.cell_size_0
                $...control.cell_size_0
                $...control.cell_size_3
                $...control.cell_size_5
                $...control.cell_size_3
                $...control.cell_size_4
            );
            cell_exp_ratios
            (
                5.0
                5.0
                5.0
                5.0
                5.0
                5.0
                5.0
                5.0
            );
        }

        // To adjust SLAVE blocks grading:
        // - guarantee start size strecthing cells size towards edge mid-point
        // - start size and end size are the same
        // - cells number inherited from MASTER blocks
        // 'B2': grading on xy edges towards the building
        // 'B3': grading on vertical edges of the building
        slave
        {
            tags            ( B2  B3 );
            cell_exp_ratios ( 3 3 );
            start_sizes     ( 
                $...control.cell_size_3
                $...control.cell_size_0
            );
            mid_sizes       (
                $...control.cell_size_2
                $...control.cell_size_2
            );
        }
    }
}


//--- Smoothing-related parameters ---//
protected
{
    // No need: set to 1.0
    extent_x_in	1.0;
    extent_x_out	1.0;
    extent_y		1.0;
    extent_z		1.0;
    grid_min_x      $..grid.coordinates.x_min;
    grid_max_x      $..grid.coordinates.x_max;
    grid_min_y      $..grid.coordinates.y_min;
    grid_max_y      $..grid.coordinates.y_max;
    grid_min_z      $..grid.coordinates.z_min;
    grid_max_z      $..grid.coordinates.z_max;

    // Exclude from smoothing cells outside these limits
    min_z           $grid_min_z;
    max_z           #calc " ${grid_max_z} * ${extent_z}";
    min_x           #calc " ${grid_min_x} * ${extent_x_in}";
    max_x           #calc " ${grid_max_x} * ${extent_x_out}";
    min_y           #calc " ${grid_min_y} * ${extent_y}";
    max_y           #calc " ${grid_max_y} * ${extent_y}";
}

//--- Adaptive mesh related parameters ---//
refine
{
    extent   0.55;
    grid_min_x      $..grid.coordinates.x_min;
    grid_max_x      $..grid.coordinates.x_max;
    grid_min_y      $..grid.coordinates.y_min;
    grid_max_y      $..grid.coordinates.y_max;
    grid_min_z      $..grid.coordinates.z_min;
    grid_max_z      $..grid.coordinates.z_max;

    // Exlude from refinement cells outside these limits
    min_x           #calc " ${grid_min_x} * ${extent}";
    max_x           #calc " ${grid_max_x} * ${extent}";
    min_y           #calc " ${grid_min_y} * ${extent}";
    max_y           #calc " ${grid_max_y} * ${extent}";
    min_z           #calc " ${grid_min_z} * ${extent}";
    max_z           #calc " ${grid_max_z} * ${extent}";
}
